# -*- coding: utf-8 -*-
"""04_fode_2_coding.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Ge5QkOGluiSfwfz_Np4OKPgHa-PgBK6

# MCQs
"""
from .MCQs import *

"""# Coding"""

# Commented out IPython magic to ensure Python compatibility.
from IPython.display import display, Markdown
from IPython.core.magic import register_cell_magic
from IPython.core.getipython import get_ipython

import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

"""## Supporting Functions"""

def strip_magic(line, cell):
    lines = cell.split('\n')
    stripped_lines = [line for line in lines if not line.strip().startswith('%')]

    if(len(lines)>len(stripped_lines)):
        print('Warning: The % magic does not work in this cell.')

    return ('\n'.join(stripped_lines))

def create_new_cell(contents):

    shell = get_ipython()
    shell.set_next_input(contents, replace=False)

"""## Q1

Magic
"""

@register_cell_magic
def L04Q1(line, cell):

    # correct answer
    def correct():
        def yprime(x, y):
            return 2*np.cos(x)*np.sin(x)

        x = np.linspace(-4, 4, 20)
        y = np.linspace(-2, 2, 20)

        X, Y = np.meshgrid(x, y)
        U = np.ones(X.shape)  # dx/dx
        V = yprime(X, Y)  # dy/dx

        # Normalizing
        N = np.sqrt(U**2 + V**2)
        U /= N
        V /= N

        sol = solve_ivp(yprime, (-3, 3), (0,), t_eval=np.linspace(-3, 3))

        plt.plot(sol.t, sol.y[0], 'r--', lw=2, label = 'Correct')
#         plt.quiver(X, Y, U, V)
        plt.legend()

        return

    globals = dict()
    exec(strip_magic(line, cell), globals)

    correct()

"""Question"""

def Code1():

    display(Markdown("""Plot a normalised direction field for the differential equation: $\\frac{dy}{dx} = 2sin(x)cos(x)$,
    in the range x = [-4, 4] and y = [-2, 2]. Integrate the equation using solve_ivp for the x-limits (-3, 3)
    and plot it on the direction field."""))

    c = """%%L04Q1
# import the required the packages


# complete the function
def yprime():
    return

x =
y =

# generate the mesh
X, Y =
U =   # dx/dx
V =   # dy/dx

# Normalizing
N =
U =
V =

# complete the solve_ivp() function call
sol = solve_ivp(, t_eval=np.linspace(-3, 3))

# plot and label

"""


    create_new_cell(c)

# Code1()

print('Code1() imported')

"""## Q2

Magic
"""

@register_cell_magic
def L04Q2(line, cell):

    # correct answer
    def correct():
        def f(x, Y):
            y1, y2 = Y
            dy1dx = y2
            dy2dx = 2
            return np.array([dy1dx, dy2dx])

        y0 = np.array([25, -10])
        tspan = (0, 10)
        sol = solve_ivp(f, tspan, y0, t_eval = np.linspace(*tspan))

        plt.plot(sol.t, sol.y[0].flatten(), 'k.-',label = 'Correct', alpha = 0.5)
        plt.legend()
        return

    globals = dict()
    exec(strip_magic(line, cell), globals)

    correct()

"""Question"""

def Code2():

    display(Markdown("""The differential equation for a parabola: $y = (x - 5)^2$ can be written as
    $\\frac{d^2y}{dx^2} = 2$ on taking its derivative. Express this in the form of a system of
    first-order differential equations. Make a plot of x vs y from x = 0 to x = 10,
    by integrating the differential equation using scipy.integrate.solve_ivp.
    Given: y(0) = 25 and y'(0) = -10."""))

    c = """%%L04Q2
# import the required packages


# complete the objective function
def f():

    return

y0 = np.array([25, -10])
tspan = (0, 10)

# complete the solve_ivp() function call
sol = solve_ivp(, t_eval = np.linspace(*tspan))

# plot with labels


"""


    create_new_cell(c)

# Code2()

print('Code2() imported')
